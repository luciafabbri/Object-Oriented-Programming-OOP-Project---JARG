package main.worldModel.generation;

import java.util.Map;
import java.util.Random;
import org.newdawn.slick.SlickException;

import main.worldModel.RoomModelImpl;
import main.worldModel.utilities.*;
import main.worldModel.utilities.graphs.RoomBFS;

public class RoomModelGeneratorImpl implements RoomModelGenerator {

	private final Map<String, Integer> currentConfig;
	private final Random random = new Random();
	private final TilesGraphGenerator graphGen = new TilesGraphGeneratorImpl();
	private EntitiesGenerator entitiesGen;
	private final RoomBFS bfs = new RoomBFS();
	private final int specialRoomID;
	private final int coinRoomID;
	private final boolean isFinalLevel;

	/**
	 * @param currentConfig, configuration map containing bounds for random
	 *                       generation and other statistics
	 * @param specialRoomID, integer ID of the special room, room that contains
	 *                       either Stairs to the next level OR the final boss
	 * @param isFinalLevel,  boolean that specifies if rooms generated by this
	 *                       generator belong to the final level
	 */
	public RoomModelGeneratorImpl(Map<String, Integer> currentConfig, int specialRoomID, int coinRoomID,
			boolean isFinalLevel) {
		this.specialRoomID = specialRoomID;
		this.currentConfig = currentConfig;
		this.coinRoomID = coinRoomID;
		this.isFinalLevel = isFinalLevel;
	}

	@Override
	public RoomModelImpl generateRoom(int index) throws SlickException {

		RoomModelImpl room = new RoomModelImpl(index);
		entitiesGen = new EntitiesGeneratorImpl(room, currentConfig);
		if (index == specialRoomID) {
			if (isFinalLevel) {
				Pair<Integer, Integer> bossTile = new Pair<Integer, Integer>(512, 256);
				room.addOccupiedTile(bossTile);
				entitiesGen.generateBoss();
			} else {
				entitiesGen.generateStairs();
			}
		}
		if (index == coinRoomID) {
			entitiesGen.generateCoin();
		}
		// key generation
		entitiesGen.generateKey();
		// enemies generation
		int numOfEnemies = currentConfig.get("minEnemies")
				+ random.nextInt(1 + currentConfig.get("maxEnemies") - currentConfig.get("minEnemies"));
		entitiesGen.generateEnemies(numOfEnemies);
		// obstacle generation
		int obstaclePercentage = currentConfig.get("minObstacles%")
				+ random.nextInt(1 + currentConfig.get("maxObstacles%") - currentConfig.get("minObstacles%"));
		int numOfObstacles;
		if (obstaclePercentage > 0) {
			numOfObstacles = GameSettings.TOTALTILES % obstaclePercentage;
		} else {
			numOfObstacles = 0;
		}
		entitiesGen.generateObstacles(numOfObstacles);
		// modifiers generation
		int numOfModifiers = currentConfig.get("minObjects")
				+ random.nextInt(1 + currentConfig.get("maxObjects") - currentConfig.get("minObjects"));
		entitiesGen.generateModifiers(numOfModifiers);
		// tiles graph generation
		room.setTilesGraph(graphGen.generateTilesGraph(room));
		// door-to-door path check, if false generate new room
		while (!bfs.areDoorsReachable(room)) {
			return (this.generateRoom(index));
		}
		return room;
	}

}
